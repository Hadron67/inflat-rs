use std::{
    f64::consts::PI,
    sync::atomic::{AtomicUsize, Ordering},
};

use libm::sqrt;
use rayon::iter::{IntoParallelRefIterator, ParallelIterator};

use crate::util::{interpolate_1d, log_interp};

fn log_div(num: f64, den: f64) -> f64 {
    let eps = 1e-20;
    (num.abs() + eps).ln() - (den.abs() + eps).ln()
}

/// Generated by deepseek
/// 计算二阶引力波能量密度谱的被积函数
///
/// # 参数
/// - `u`: 第一个积分变量 (f64)
/// - `v`: 第二个积分变量 (f64)
/// - `k`: 波数 (f64)
/// - `p_h`: 功率谱函数，接受f64返回f64
///
/// # 返回值
/// 被积函数值 (f64)
pub fn tigw_2_integrand(u: f64, v: f64, k: f64, mut p_h: impl FnMut(f64) -> f64) -> f64 {
    // 预计算幂次项以提高效率和可读性
    let u2 = u * u;
    let u4 = u2 * u2;
    let u6 = u4 * u2;
    let u8 = u4 * u4;

    let v2 = v * v;
    let v4 = v2 * v2;
    let v6 = v4 * v2;
    let v8 = v4 * v4;

    // 计算关键因子 [(u-v)^2-1]^2 * [(u+v)^2-1]^2
    let term1 = (u - v).powi(2) - 1.0;
    let term2 = (u + v).powi(2) - 1.0;
    let factor = term1.powi(2) * term2.powi(2);

    // 处理边界奇点：当因子接近零时直接返回0
    if factor.abs() < 1e-20 {
        return 0.0;
    }

    // 计算对数项中的参数并确保数值稳定性
    let num = 1.0 - (u + v).powi(2);
    let den = 1.0 - (u - v).powi(2);

    // 处理除零和log(0)问题：添加微小偏移量
    let eps = 1e-20;
    let log_arg = (num.abs() + eps) / (den.abs() + eps);
    let ln_val = log_arg.ln();

    // 计算括号内的三项表达式
    // 第一项：多项式项
    let term_a = 64.0 * u2 * v2 * (1.0 + u4 + v4 + 6.0 * (u2 + v2) + 6.0 * u2 * v2);

    // 第二项：含对数项
    let term_b = 16.0
        * u
        * v
        * (1.0 + u6 + v6 + 15.0 * (u4 + v4) + 15.0 * (u2 + v2) + 15.0 * u2 * v2 * (u2 + v2 + 6.0))
        * ln_val;

    // 第三项：含π²和对数平方项
    let poly = 1.0 - 7.0 * u8 + 4.0 * v2 + 126.0 * v4 + 116.0 * v6 + 9.0 * v8
        - 12.0 * u6 * (5.0 + 7.0 * v2)
        + 2.0 * u4 * (7.0 + 118.0 * v2 + 35.0 * v4)
        + 4.0 * u2 * (13.0 + 105.0 * v2 + 151.0 * v4 + 35.0 * v6);

    let term_c = poly * (std::f64::consts::PI.powi(2) + ln_val.powi(2));

    // 组合括号内的三项
    let bracket = term_a + term_b + term_c;

    // 计算常数因子 1/(3145728 * u^8 * v^8)
    let const_factor = 1.0 / (3145728.0 * u8 * v8);

    // 最终组合所有部分
    p_h(u * k) * p_h(v * k) * const_factor * factor * bracket
}

pub fn sigw_2_integrand<F: FnMut(f64) -> f64>(u: f64, v: f64, k: f64, mut p_zeta: F) -> f64 {
    let factor1 = ((4.0 * v * v - (1.0 + v * v - u * u).powi(2)) / 4.0 / u / v).powi(2);
    let factor2 = (3.0 * (u * u + v * v - 3.0) / 4.0 / (u * v).powi(2)).powi(2);
    let log_den = log_div(3.0 - (u + v).powi(2), 3.0 - (u - v).powi(2));
    let factor3 = (-4.0 * u * v + (u * u + v * v - 3.0) * log_den).powi(2)
        + if u + v >= sqrt(3.0) {
            PI.powi(2) * (u * u + v * v - 3.0).powi(2)
        } else {
            0.0
        };
    1.0 / 12.0 * factor1 * factor2 * factor3 * p_zeta(u * k) * p_zeta(v * k)
}

pub fn uv_integrate<F>(u_max: f64, du: f64, dv: f64, mut integrand: F) -> f64
where
    F: FnMut(f64, f64) -> f64,
{
    let u_count = (u_max / du).ceil() as usize + 1;
    let mut ret = 0.0;
    for u_index in 0..u_count {
        let u = du * (u_index as f64);
        let v_min = (1.0 - u).abs();
        let v_max = 1.0 + u;
        let v_count = ((v_max - v_min) / dv).ceil() as usize + 1;
        for v_index in 0..v_count {
            let v = v_min + (v_index as f64) * dv;
            ret += integrand(u, v);
        }
    }
    ret * du * dv
}

pub fn tigw_2_spectrum_one(
    k_data: &[f64],
    spectrum: &[f64],
    k: f64,
    u_max: f64,
    du: f64,
    dv: f64,
) -> f64 {
    uv_integrate(u_max, du, dv, |u, v| {
        tigw_2_integrand(u, v, k, move |k0| {
            interpolate_1d(k_data, spectrum, k0, false, &log_interp)
        })
    })
}

pub fn tigw_2_spectrum<Step>(
    k_data: &[f64],
    spectrum: &[f64],
    u_max: f64,
    du: f64,
    dv: f64,
    step_monitor: Step,
) -> Vec<f64>
where
    Step: Fn(usize, usize) + Sync,
{
    let done_count = AtomicUsize::new(0);
    k_data
        .par_iter()
        .map(|k| {
            let ret = tigw_2_spectrum_one(k_data, spectrum, *k, u_max, du, dv);
            step_monitor(done_count.fetch_add(1, Ordering::SeqCst) + 1, k_data.len());
            ret
        })
        .collect::<Vec<_>>()
}
